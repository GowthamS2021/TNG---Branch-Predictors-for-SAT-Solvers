#include "ooo_cpu.h"
#include <cmath>
#include <unordered_map>

#define BIMODAL_TABLE_SIZE 16384
#define BIMODAL_LOGSIZE 14
#define BIMODAL_PRIME 16381
// #define MAX_COUNTER 7
// #define INDEX_OF_TABLE 10
// #define TAG_LENGTH 8
#define NO_OF_TABLES 12
#define TAGE_RESET_USEFUL_INTERVAL 512000
#define GLOBAL_HISTORY_SIZE 1024
#define PATH_HISTORY_SIZE 32
// #define MIN_VALUE 0
#define INTIAL_STATE 8
#define TAG_COUNTER_BITS 4
#define BIMODAL_BITS 2
#define USEFUL_BITS_IN_TABLE 2
#define USE_ALT_ON_NA_BITS 4

#define LOOP_ENTRIES 256
#define LOOP_ASSOCIATIVITY 4
#define LOOP_LOGINDEX 6
#define LOOP_LOGWAY 2
#define TAGSIZE 14
#define ITERATION_LENGTH 14
#define LOOP_AGE 31


// int bimodal_table[NUM_CPUS][BIMODAL_TABLE_SIZE];
// BIMODAL PREDICTOR CLASS
// TAGE TABLE entry class
// TAGE TABLE Class
// TAGE Class
const int TAGE_TAG_WIDTHS[NO_OF_TABLES] = {7, 7, 8, 8, 9, 10, 11, 12, 12, 13, 14, 15};
const int TAGE_HISTORY_LENGTHS[NO_OF_TABLES] = {4, 6, 10, 16, 25, 40, 64, 101 , 160, 254, 403, 640};
const int TAGE_INDEX_SIZE[NO_OF_TABLES] = {10, 10, 11, 11, 11, 11, 10, 10, 10, 10, 9, 9};

bool GHRA[GLOBAL_HISTORY_SIZE];
uint8_t PHRA[PATH_HISTORY_SIZE];

class ENTRY
{
public:
    int u;   // 2 bit u value
    int ctr; // 3 bit ctr value
    int tag; // 8 bit tag

    ENTRY()
    {
        u = 0;
        ctr = INTIAL_STATE;
        tag = 0;
    }
};

// TODO : have to intialise properly with the index and history length
class TAGE_TABLE
{
    int NoOfElements;
    int INDEX;
    int history;

public:
    ENTRY *TAGE_ENTRIES;
    TAGE_TABLE(){;}
    TAGE_TABLE(int n, int INDEX)
    {
        NoOfElements = round(pow(2, n));
        this->INDEX = INDEX;
        TAGE_ENTRIES = new ENTRY[NoOfElements];
        history = TAGE_HISTORY_LENGTHS[INDEX];
    }

    void set(int n,int INDEX){
        NoOfElements = round(pow(2, n));
        this->INDEX = INDEX;
        TAGE_ENTRIES = new ENTRY[NoOfElements];
        history = TAGE_HISTORY_LENGTHS[INDEX];
    }

    uint64_t XORED_Path_history()
    {
        int length = (history > 16) ? 16 : history;
        uint64_t path_history = 0;
        for (int i = PATH_HISTORY_SIZE - 1; i >= 0; i--)
        {
            path_history = (path_history << 1) | PHRA[i];
        }
        path_history &= ((1 << length) - 1);
        uint64_t path_1 = path_history & ((1 << TAGE_INDEX_SIZE[INDEX]) - 1), path_2 = path_history >> TAGE_INDEX_SIZE[INDEX];
        path_2 = ((path_2 << history) & ((1 << TAGE_INDEX_SIZE[INDEX]) - 1)) + (path_2 >> abs(TAGE_INDEX_SIZE[INDEX] - history));
        uint64_t path = path_1 ^ path_2;
        return ((path << history) & ((1 << TAGE_INDEX_SIZE[INDEX]) - 1)) + (path >> abs(TAGE_INDEX_SIZE[INDEX] - history));
    }

    uint64_t XORED_Global_history(int size)
    {
        uint64_t xored_history = 0, temp = 0;
        for (int i = 0; i < TAGE_HISTORY_LENGTHS[INDEX]; i++)
        {
            temp = (temp << 1) | GHRA[i];
            if (!((i+1) % size) || i == TAGE_HISTORY_LENGTHS[INDEX]-1 )
            {
                xored_history ^= temp;
                temp = 0;
            }
        }
        return xored_history;
    }

    uint64_t getIndex(uint64_t pc)
    {
        uint64_t global = XORED_Global_history(TAGE_INDEX_SIZE[INDEX]);
        uint64_t path = XORED_Path_history();
        return (global ^ pc ^ (pc >> (abs(TAGE_INDEX_SIZE[INDEX] - history) + 1)) ^ path) & ((1 << TAGE_INDEX_SIZE[INDEX]) - 1);
    }

    uint64_t getTag(uint64_t pc)
    {
        uint64_t global = XORED_Global_history(TAGE_TAG_WIDTHS[INDEX]) ^ XORED_Global_history(TAGE_TAG_WIDTHS[INDEX] - 1);
        return (global ^ pc) & ((1 << TAGE_TAG_WIDTHS[INDEX]) - 1);
    }
};

class TAGE
{
private:
    int USE_ALT_ON_NA; // 4 bit counter
    int tage_bimodal[BIMODAL_TABLE_SIZE];
    TAGE_TABLE *tables = new TAGE_TABLE[NO_OF_TABLES];
    bool nor_pred, alter_pred;
    int nor_pred_comp, alter_pred_comp;
    bool tage_pred;
    int branches;
    bool is_weak;

public:
    void initialize()
    {
        for (int i = 0; i < NO_OF_TABLES; i++)
        {
            tables[i].set(TAGE_INDEX_SIZE[i],i);            
        }
        for (int i = 0; i < BIMODAL_TABLE_SIZE; i++)
        {
            tage_bimodal[i] = 1 << (BIMODAL_BITS - 1);
        }
        branches = 0;
        nor_pred = false;
        alter_pred = false;
        nor_pred_comp = 0;
        alter_pred_comp = 0;
        tage_pred = false;
        USE_ALT_ON_NA = 8;
        is_weak = true;
    }

    // bool predict(uint64_t pc);
    int bimodal_index(uint64_t pc)
    {
        // TODO
        return (pc ^ (pc >> BIMODAL_LOGSIZE)) & ((1 << BIMODAL_LOGSIZE) - 1);
        // return (pc & ((1 << BIMODAL_LOGSIZE) - 1))
    }

    void update_count(int *ctr, bool taken, int MAX)
    {
        if (taken && *ctr < MAX)
        {
            (*ctr)++;
        }
        else if (!taken && *ctr > 0)
        {
            (*ctr)--;
        }
    }

    bool match_at_comp_n(uint64_t pc, int comp)
    {
        int index = tables[comp - 1].getIndex(pc);
        int tag = tables[comp - 1].getTag(pc);
        return tables[comp - 1].TAGE_ENTRIES[index].tag == tag;
    }

    bool return_prediction(uint64_t pc, int component)
    {
        if (component == 0)
        {
            int ind = bimodal_index(pc);
            return tage_bimodal[ind] >= (1 << (BIMODAL_BITS - 1));
        }
        else
        {
            int ind = tables[component - 1].getIndex(pc);
            return tables[component - 1].TAGE_ENTRIES[ind].ctr >= (1 << (TAG_COUNTER_BITS - 1));
        }
    }

    bool predict(uint64_t pc)
    {

        nor_pred_comp = 0;
        alter_pred_comp = 0;

        for (int count = NO_OF_TABLES; count > 0; count--)
        {
            if (match_at_comp_n(pc, count))
            {
                nor_pred_comp = count;
                break;
            }
        }
        for (int count = nor_pred_comp - 1; count > 0; count--)
        {
            if (match_at_comp_n(pc, count))
            {
                alter_pred_comp = count;
                break;
            }
        }

        nor_pred = return_prediction(pc, nor_pred_comp);
        alter_pred = return_prediction(pc, alter_pred_comp);

        if (nor_pred_comp == 0)
        {
            tage_pred = nor_pred;
        }
        else
        {
            int ind = tables[nor_pred_comp - 1].getIndex(pc);
            is_weak = 1 >= abs(2 * tables[nor_pred_comp - 1].TAGE_ENTRIES[ind].ctr + 1 - (1 << TAG_COUNTER_BITS));

            if (USE_ALT_ON_NA < 8 || !is_weak)
                tage_pred = nor_pred;
            else
                tage_pred = alter_pred;
        }

        return tage_pred;
    }

    void update_Tage(uint64_t pc, bool taken)
    {
        bool checker = (nor_pred == alter_pred);
        if (nor_pred_comp > 0)
        {
            ENTRY *pred1 = &tables[nor_pred_comp - 1].TAGE_ENTRIES[tables[nor_pred_comp-1].getIndex(pc)];
            int useful_bit = pred1->u;
            if (is_weak)
            {
                if (!checker)
                {
                    bool foo = nor_pred != taken;
                    update_count(&USE_ALT_ON_NA, foo, ((1 << USE_ALT_ON_NA_BITS) - 1));
                }
            }
            if (alter_pred_comp > 0)
            {
                ENTRY *pred2 = &tables[alter_pred_comp - 1].TAGE_ENTRIES[tables[alter_pred_comp-1].getIndex(pc)];
                if (useful_bit == 0)
                {
                    update_count(&pred2->ctr, taken, (1 << TAG_COUNTER_BITS) - 1);
                }
            }
            else
            {
                if (useful_bit == 0)
                {
                    update_count(&tage_bimodal[bimodal_index(pc)], taken, (1 << BIMODAL_BITS) - 1);
                }
            }
            if (!checker)
            {
                if (nor_pred == taken)
                {
                    update_count(&pred1->u, nor_pred == taken, (1 << USEFUL_BITS_IN_TABLE) - 1);
                }
                else
                {
                    if (USE_ALT_ON_NA < 8)
                    {
                        update_count(&pred1->u, nor_pred == taken, (1 << USEFUL_BITS_IN_TABLE) - 1);
                    }
                }
            }
            update_count(&pred1->ctr, taken, (1 << TAG_COUNTER_BITS) - 1);
        }
        else
        {
            update_count(&tage_bimodal[bimodal_index(pc)], taken, (1 << BIMODAL_BITS) - 1);
        }
        if (tage_pred != taken)
        {
            int rand = random();
            bool cond1 = ((rand % 4) == 0);
            bool cond2 = ((rand % 4) == 2);
            int bcomp = nor_pred_comp;
            if (!cond1 && !cond2)
            {
                bcomp++;
            }
            else if(cond1){
                bcomp = bcomp + 3 ;
            }
            else{
                bcomp = bcomp + 2 ; 
            }
            bool replace = false;
            for(int i = nor_pred_comp + 1 ; i <= NO_OF_TABLES  ;i++){
                    ENTRY *t = &tables[i - 1].TAGE_ENTRIES[tables[i-1].getIndex(pc)];
                    if(t->u == 0){
                        replace = true;
                        break;
                    }
            }
            
            for(int i = bcomp ; i <= NO_OF_TABLES ; i++ ){
                if(!replace && i == bcomp){
                    // tables[bcomp - 1].TAGE_ENTRIES[tables[bcomp - 1].getIndex(ip)]
                    tables[bcomp - 1].TAGE_ENTRIES[tables[bcomp - 1].getIndex(pc)].u = 0;

                }
                ENTRY *t = &tables[i-1].TAGE_ENTRIES[tables[i-1].getIndex(pc)];
                if(t->u == 0){
                    t->tag = tables[i - 1].getTag(pc);
                    t->ctr = (1 << (TAG_COUNTER_BITS - 1));
                    break;
                }

            }
        }
    
    
    // global history update and path history update 

        for(int i=GLOBAL_HISTORY_SIZE-1;i>=1;i--) GHRA[i] = GHRA[i-1];
        GHRA[0] = taken;
        for(int i=PATH_HISTORY_SIZE-1;i>=1;i--)PHRA[i] = PHRA[i-1];
        PHRA[0] = pc & 1;
        branches ++;
        if((branches % TAGE_RESET_USEFUL_INTERVAL) == 0){
            branches = 0;
            for(int i = 0 ; i < NO_OF_TABLES;i++){
                for(int j = 0 ; j < (1 << TAGE_INDEX_SIZE[i])  ;j++){
                    tables[i].TAGE_ENTRIES[j].u >>= 1;
                }
            }
        }         
    
    }
};

class LOOP_ENTRY{
    public:
        uint64_t tag;
        uint64_t PastIter;
        uint64_t CurrentIter;
        uint64_t age;
        uint64_t confidence;

        LOOP_ENTRY(){
            tag = 0;
            PastIter = 0;
            CurrentIter = 0;
            age = 0;
            confidence = 0;
        }
};

class LOOP_PREDICTOR{
    LOOP_ENTRY table[LOOP_ENTRIES];
    // variables that are used across both predict and update
    int Hit,Predict_confidence;
    uint64_t Index, PrevTag;

    public:

        bool predict(uint64_t pc){
            // cout << "Loop Predictor Predict function call" << endl;
            Hit = -1;
            int Prediction;
            Index = (pc & ((1 << LOOP_LOGINDEX)-1)) << LOOP_LOGWAY;
            PrevTag = (pc >> LOOP_LOGINDEX) & ((1 << LOOP_LOGWAY)-1);
            for (uint64_t i=Index;i<Index + LOOP_ASSOCIATIVITY;i++){
                if (table[i].tag == PrevTag){
                    Hit = i;
                    if (table[i].CurrentIter < table[i].PastIter) Prediction = 1;
                    else Prediction = 0;
                    break;                   
                }
            }
            if (Hit == -1) {
                Predict_confidence = 0;
            }
            else Predict_confidence = (Prediction & 1) + ((table[Hit].confidence == 3) << 1);
            return Predict_confidence;
        }

        void update(uint64_t pc, uint64_t taken, uint64_t TAGE_Prediction){
            // int Index = (pc & ((1 << LOOP_LOGINDEX)-1)) << LOOP_LOGWAY;
            // int PrevTag = (pc >> LOOP_LOGINDEX) & ((1 << LOOP_LOGWAY)-1);
            // int Hit = 0;

            // cout << "Loop Predictor Update function call" << endl;
            uint64_t Prediction = Predict_confidence & 1;
            bool confidence_level = (Predict_confidence >> 1);     
            // if (Hit >= 0){
            //     if (confidence_level){
            //         if (taken != Prediction){
            //             table[Hit].PastIter = 0;
            //             table[Hit].CurrentIter = 0;
            //             table[Hit].confidence = 0;
            //             table[Hit].age = 0;
            //             return;
            //         }
            //         if (taken != TAGE_Prediction){
            //             if (table[Hit].age < LOOP_AGE) table[Hit].age++;
            //         }
            //     }
            //     table[Hit].CurrentIter = (table[Hit].CurrentIter + 1) & ( (1 << ITERATION_LENGTH) - 1 );
            //     if (table[Hit].CurrentIter > table[Hit].PastIter){
            //         table[Hit].confidence = 0;
            //         if (table[Hit].PastIter != 0) table[Hit].age = 0;
            //         table[Hit].PastIter = 0;
            //     }
            //     if (!taken){
            //         if (table[Hit].CurrentIter == table[Hit].PastIter){
            //             (table[Hit].confidence+1 > 3) ? table[Hit].confidence = 3 : table[Hit].confidence += 1;
            //             if ((table[Hit].CurrentIter > 0) && (table[Hit].CurrentIter < 3)){
            //                 table[Hit].PastIter = 0;
            //                 table[Hit].age = 0;
            //                 table[Hit].confidence = 0;
            //             }
            //             cout << "confidence: " << table[Hit].confidence << endl;
            //         }
            //         else{
            //             table[Hit].confidence = 0;
            //             if (table[Hit].PastIter == 0){
            //                 table[Hit].PastIter = table[Hit].CurrentIter;                            
            //             }
            //             else {
            //                 table[Hit].PastIter = 0;
            //                 table[Hit].age = 0;
            //             }
            //         }
            //     }
            // }
            // else {
            //     if (taken) {
            //         for (int i = Index; i < Index + LOOP_ASSOCIATIVITY ; i++){
            //             if (table[i].age == 0){
            //                 table[i].age = LOOP_AGE;
            //                 table[i].tag = PrevTag;
            //                 table[i].confidence = 0;
            //                 table[i].PastIter = 0;
            //                 table[i].CurrentIter = 1;
            //                 break;
            //             }
            //             else if (table[i].age > 0) table[i].age--;
            //         }
            //     }
            // }
            if (Hit == -1 && table[Index].age > 0) {
                table[Index].age--;
            }   
            else {
                if (table[Index].age == 0){
                    for (int i = Index; i < Index + LOOP_ASSOCIATIVITY ; i++){
                        if (table[i].age == 0){
                            table[i].age = LOOP_AGE;
                            table[i].tag = PrevTag;
                            table[i].confidence = 0;
                            table[i].PastIter = 0;
                            table[i].CurrentIter = 1;
                            break;
                        }
                        else if (table[i].age > 0) table[i].age--;
                    }
                }
                else {
                    if ((Predict_confidence & 1) == taken){
                        if (table[Index].CurrentIter != table[Index].PastIter) table[Index].CurrentIter++;
                        else if (table[Index].CurrentIter == table[Index].PastIter){
                            table[Index].CurrentIter = 0;
                            table[Index].confidence = min(table[Index].confidence+1,(unsigned long)3);
                        }
                    }
                    else{
                        if (table[Index].age == LOOP_AGE){
                            table[Index].PastIter = table[Index].CurrentIter;
                            table[Index].CurrentIter = 0;
                            table[Index].confidence = 1;
                        }
                    }
                }
            }

        }

        
};

#define CF_COUNTER_BITS 8
#define CF_TAG_BITS 7
#define CF_TABLE_SIZE 64

class CorrectionFilter{

public:
    class cf_entry{
        public:
        int tag;
        int count;

        cf_entry(){
            tag = 0;
            count = 1;
        }
    };

    unordered_map<uint64_t, cf_entry> cf_table;

    bool check_hit_cf(uint64_t pc, bool tage_pred){
        bool tablecheck = false;
        if(cf_table.find(pc) != cf_table.end()){
            //if(tage_pred == (cf_table[pc].count < (1 << (CF_COUNTER_BITS-1))))
            if(true)
                if(cf_table[pc].count < 63) cf_table[pc].count ++;
            else
                if(cf_table[pc].count > 0) cf_table[pc].count--;
            
          // cout << pc << " : " << cf_table[pc].count << endl;
            
            if((cf_table[pc].count >=  (1 << (CF_COUNTER_BITS-1))) && cf_table[pc].tag != 0)
                tablecheck = true;
        }
        return tablecheck;
    }

    void cf_update(uint64_t pc, bool tage_pred, bool outcome){


        if(!(outcome == tage_pred)){
        bool tablecheck = check_hit_cf(pc, true);
            if(!tablecheck){

           // cout << pc << " : " <<  cf_table[pc].count << endl;
            cf_entry new_entry;
            new_entry.count = 1;
            new_entry.tag = (pc >> 2) & 0x7F;
            if(cf_table.size() == CF_TABLE_SIZE){
                uint64_t minpc = 0xFFFFFFFFFFFFFFFF;
                int mincount = 0xFFFFFFFF;
                int mintag = 0xFFFFFFFF;
                int currcount, currtag;
                uint64_t currpc;
                for(auto &e : cf_table){
                    currpc = e.first;
                    currcount = e.second.count;
                    currtag = e.second.tag;
                    if(currcount < mincount || (currcount == mincount && currtag < mintag)){
                        minpc = currpc;
                        mincount = currcount;
                        mintag = currtag;
                    }
                }
                cf_table.erase(minpc);
            }
            cf_table[pc] = new_entry;
        }
        }
        else{
            check_hit_cf(pc, false);
        }
    }

};

CorrectionFilter correction_filter;

TAGE predictor;
LOOP_PREDICTOR loop_predictor;
uint64_t tage_prediction, loop_prediction;
int Loop_Correct = 0;

void O3_CPU::initialize_branch_predictor()
{
    cout << "CPU " << cpu << " L-TAGE branch predictorss" << endl;
    predictor.initialize();
}

uint8_t O3_CPU::predict_branch(uint64_t ip)
{
    // uint32_t hash = ip % BIMODAL_PRIME;
    // uint8_t prediction = (bimodal_table[cpu][hash] >= ((MAX_COUNTER + 1) / 2)) ? 1 : 0;
    tage_prediction = predictor.predict(ip);
 
    

    loop_prediction = loop_predictor.predict(ip); 
    bool finalpred = tage_prediction;
    // cout << "loop_prediction: " << loop_prediction << endl;
    if ((loop_prediction >= 2) && (Loop_Correct >= 0)) {
        // cout << " loop Prediction is sent back" << endl;
        finalpred = (loop_prediction & 1);
    }
    

   // bool cf_hit = false;
   // if(correction_filter.cf_table.find(ip) != correction_filter.cf_table.end())
   //     cf_hit = correction_filter.cf_table[ip].count >= (1 << (CF_COUNTER_BITS-1)) ;
   // cout << cf_hit << endl;
   // if(cf_hit){
   //     cout << correction_filter.cf_table[ip].count << endl;
   //     return !finalpred;
   // }
    return finalpred;
 
    
}

void O3_CPU::last_branch_result(uint64_t ip, uint8_t taken)
{
    // uint32_t hash = ip % BIMODAL_PRIME;

    // if (taken && (bimodal_table[cpu][hash] < MAX_COUNTER))
    //     bimodal_table[cpu][hash]++;
    // else if ((taken == 0) && (bimodal_table[cpu][hash] > 0))
    //     bimodal_table[cpu][hash]--;
    predictor.update_Tage(ip,taken);
    loop_predictor.update(ip,taken,tage_prediction);
    //correction_filter.cf_update(ip, tage_prediction, taken);
    if (loop_prediction >= 2 && tage_prediction != loop_prediction) {
        // cout << " loop correct increased" << endl;
        if (taken == loop_prediction) Loop_Correct = min(Loop_Correct+1,127);
        else Loop_Correct = max(Loop_Correct-1,-126);
    }
}
